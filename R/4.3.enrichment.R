#' Gene Set Enrichment Analysis
#'
#' Performs gene set enrichment analysis based on DGEA results.
#'
#' @param mtd Enrichment test method (set to "fgsea" by default).
#' @param pw_source Pathway reference source
#' (either "Reactome", "GO", or "Custom").
#' Please note that if the source is "Custom,"
#' a custom gene set list file must be specified by pw_cstm.
#' @param gmt Gene matrix transposed file containing either Reactome or
#' GO gene set IDs.
#' @param pw_cstm A text file consisting of at least two columns,
#' including gene names and the custom gene set IDs. Must be specified
#' if pw_source is "Custom," but is otherwise optional. The gene sets
#' are automatically appended to the specified source if pw_source is
#' "Reactome" or "GO."
#' @param colg Gene name column in custom gene list.
#' @param colid Gene set ID column in custom gene list.
#' @param colct Cell type column in DGEA results table, if applicable.
#' @param colfc Fold change column in DGEA results table.
#' @param deg A table of DGEA results generated by sc_diff or a
#' table of DGEA results containing p-values, fold changes, and gene names.
#' If performing GSEA for single-cell datasets, the DGEA results should
#' also contain an additional column specifying the cell type each test
#' was performed in.
#' @param core_num Number of cores to use for parallel processing
#' (default is 0).
#' @return A data frame containing GSEA results based on the
#' specified DGEA results table.
#' @examples
#'
#' # sc_enrichment(
#' #   gmt = "ReactomePathways.gmt",
#' #   pw_cstm = "gref_v01.txt",
#' #   deg = "dgea_results.txt"
#' # )
#'
#' @export
sc_enrichment <- function(
  mtd = "fgsea",
  pw_source = "Reactome",
  gmt = NULL,
  pw_cstm = NULL,
  colg = "Gene",
  colid = "SetID",
  colct = "CellType",
  colfc = "log2FC",
  deg,
  core_num = 0
) {
  # Set parameters
  m1 <- mtd
  pw1 <- pw_source
  pw2 <- pw_cstm
  g1 <- gmt
  c1 <- colg
  c2 <- colid
  c3 <- colct
  c4 <- colfc
  d1 <- deg
  cn <- core_num
  # Format gene lists for GSEA
  if (mtd == m1) {
    # Generate gene set names and gene set lists
    if (pw_source == pw1 || pw_source == pw1) {
      # format gmt file
      gmt1 <- g1
      ## read file
      gset <- scan(gmt1, what = "", sep = "\n")
      ## convert strings into vectors
      gsetid <- strsplit(gset, "\t")
      ## format as data frame
      gsetnm <- setNames(
        data.frame(
          cbind(
            sapply(gsetid, "[[", 1),
            sapply(gsetid, "[[", 2)
          )
        ),
        c("GenesetID", "Description")
      )
      gset <- fgsea::gmtPathways(gmt1)
    }
    # Format custom gene list if applicable
    if (!is.null(pw2)) {
      # Read file
      gcstm <- read.table(
        pw2,
        sep = "\t",
        header = TRUE
      )
      # Custom gene set names
      gcstnm <- dplyr::bind_rows(
        lapply(
          seq.int(1, length(unique(gcstm[[c2]])), 1),
          function(i) {
            data.frame(
              "GenesetID" = unique(gcstm[[c2]])[[i]],
              "Description" = "Custom gene list"
            )
          }
        )
      )
      # Custom gene set lists
      gcstid <- setNames(
        lapply(
          seq.int(1, length(unique(gcstm[[c2]])), 1),
          function(i) {
            gcstm[
              gcstm[[c2]] == unique(gcstm[[c2]])[[i]],
            ][[c1]]
          }
        ),
        unique(gcstm[[c2]])
      )
    }
    # Combine gene set names and lists if using both Reactome/GO
    # and custom gene lists; otherwise proceed with custom only
    if (pw_source == pw1 && is.null(pw2)) {
      print("Must specify custom gene set list if performing GSEA on custom lists!") # nolint
    }
    if (pw_source == pw1 && !is.null(pw2)) {
      gname <- gcstnm
      glist <- gcstid
    }
    if (
      pw_source == pw1 || pw_source == pw1 && !is.null(pw2)
    ) {
      gname <- rbind(gsetnm, gcstnm)
      glist <- c(gset, gcstid)
    }
    if (
      pw_source == pw1 || pw_source == pw1 && is.null(pw2)
    ) {
      gname <- gsetnm
      glist <- gset
    }
    # Load DEG results and perform GSEA
    gsea_in <- read.table(
      d1,
      sep = "\t",
      header = TRUE
    )
    gcol <- names(gsea_in)[grepl("GENE|gene|Gene", names(gsea_in))]
    ## Exclude unannotated or non-coding genes
    gsea_in <- gsea_in[!grepl("ENSG0|LINC0", gsea_in[[gcol]]), ]
    # Run GSEA for each cell type or full dataset if analyzing bulk Seq
    if (c3 %in% names(gsea_in)) {
      ## Calculate GSEA per cell type
      gsea_out <- dplyr::bind_rows(
        lapply(
          seq.int(1, length(unique(gsea_in[[c3]])), 1),
          function(i) {
            # Subset data
            l1 <- unique(gsea_in[[c3]])
            t1 <- gsea_in[gsea_in[[c3]] == l1[[i]], ]
            t1 <- setNames(t1[[c4]], t1[[gcol]])
            # GSEA
            t2 <- fgsea::fgseaMultilevel(
              glist,
              t1,
              minSize = 5,
              maxSize = 500,
              nproc = cn
            )
            # Format results table
            t2names <- gname[
              gname[["GenesetID"]] %in% t2[["pathway"]],
            ]
            t2[["leadingEdge"]] <- sapply(
              t2[["leadingEdge"]],
              paste, collapse = ","
            )
            t2 <- t2[order(t2[["pval"]]), ]
            t2names[["pathway"]] <- t2names[["GenesetID"]]
            t3 <- dplyr::select(dplyr::left_join(
              t2names,
              t2,
              by = "pathway"
            ), -c("pathway"))
            t3 <- t3[order(t3[["pval"]]), ]
            t3 <- dplyr::select(
              dplyr::mutate(
                t3,
                "CellType" = l1[[i]]
              ), "CellType", everything()
            )
            return(t3) # nolint
          }
        )
      )
    }
    if (c3 %in% names(gsea_in) == FALSE) {
      ## Calculate GSEA for selected DGEA results table
      gsea_fun <- function(x) {
        # Subset data
        t1 <- setNames(x[[c4]], x[[gcol]])
        # GSEA
        t2 <- fgsea::fgseaMultilevel(
          glist,
          t1,
          minSize = 5,
          maxSize = 500,
          nproc = cn
        )
        # Format results table
        t2names <- gname[
          gname[["GenesetID"]] %in% t2[["pathway"]],
        ]
        t2[["leadingEdge"]] <- sapply(
          t2[["leadingEdge"]],
          paste, collapse = ","
        )
        t2 <- t2[order(t2[["pval"]]), ]
        t2names[["pathway"]] <- t2names[["GenesetID"]]
        t3 <- dplyr::select(dplyr::left_join(
          t2names,
          t2,
          by = "pathway"
        ), -c("pathway"))
        t3 <- t3[order(t3[["pval"]]), ]
        return(t3) # nolint
      }
      gsea_out <- gsea_fun(gsea_in)
    }
  }
  return(gsea_out) # nolint
}

#' Enrichment Plot
#'
#' Plots GSEA results generated by sc_enrichment. By default, the
#' top n pathways are plotted unless otherwise specified.
#'
#' @param drich A sc_enrichment output result.
#' @param plist (optional) Provide a vector of pathway names for
#' plotting enrichment results.
#' @param top_pw Number of pathways to plot, ranked by p-value.
#' @return An enrichment plot displaying the effect size and p-values
#' from a GSEA object.
#' @examples
#'
#' # sc_enrich_plot(drich = enr_res)
#'
#' @export
sc_enrich_plot <- function(
  drich,
  plist = NULL,
  top_pw = 10
) {
  # Set parameters
  d1 <- drich
  p1 <- plist
  p2 <- top_pw
  # Format input
  if (!is.null(p1)) {
    d2 <- d1[d1[["GenesetID"]] %in% p1, ]
    d2[["GenesetID"]] <- factor(d2[["GenesetID"]], levels = p1)
  }
  if (is.null(p1)) {
    d2 <- d1[order(d1[["pval"]]), ]
    d2 <- d2[1:p2, ]
    d2 <- d2[order(d2[["NES"]]), ]
  }
  ## Split by cell type if applicable
  if ("CellType" %in% names(d2)) {
    if (length(unique(d2[["CellType"]])) > 1) {
      d2[["GenesetID"]] <- paste(
        d2[["CellType"]], d2[["GenesetID"]],
        sep = " - "
      )
      d2[["GenesetID"]] <- factor(
        d2[["GenesetID"]], levels = d2[["GenesetID"]]
      )
    }
    if (length(unique(d2[["CellType"]])) == 1) {
      d2[["GenesetID"]] <- factor(
        d2[["GenesetID"]], levels = d2[["GenesetID"]]
      )
    }
  }
  if ("CellType" %in% names(d2) == FALSE) {
    d2[["GenesetID"]] <- factor(
      d2[["GenesetID"]], levels = d2[["GenesetID"]]
    )
  }
  ## Plot
  out1 <- ggplot2::ggplot(
    data = d2,
    ggplot2::aes(
      x = .data[["NES"]],
      y = .data[["GenesetID"]],
      fill = .data[["NES"]]
    )
  ) +
    ## Add bars
    ggplot2::geom_col(
      ggplot2::aes(
        linetype = ifelse(
          .data[["padj"]] < 0.1, "a", "b"
        ),
        alpha = ifelse(
          .data[["padj"]] < 0.1, 1, 0.5
        )
      ),
      color = "black",
      width = 0.1,
      show.legend = FALSE
    ) +
    ## Add points
    ggplot2::geom_point(
      shape = 21,
      col = "black",
      ggplot2::aes(
        size = ifelse(
          .data[["padj"]] < 0.1, .data[["size"]], 0
        )
      )
    ) +
    ## Theme
    sc_theme1() +
    ## Axis labels
    ggplot2::xlab("Normalized Enrichment Score") +
    ggplot2::ylab("Gene Set ID") +
    ## Gradient and size scaling
    ggplot2::scale_fill_gradientn(
      name = "NES",
      colors = col_grad(scm = 5)
    ) +
    ggplot2::scale_size_area(
      name = "Gene Set Size",
      max_size = 16
    )
    return(out1) # nolint
}
